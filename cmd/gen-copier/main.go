package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"

	"hechuqiu.github.io/gen-copier/internal/copier-generate"
)

// ParseDirRecursive 递归解析目录及其子目录中的所有 Go 文件
func ParseDirRecursive(fset *token.FileSet, root string, filter func(os.FileInfo) bool, mode parser.Mode) (map[string]*ast.Package, error) {
	pkgs := make(map[string]*ast.Package)
	var firstError error

	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		// 处理可能的 Walk 错误
		if err != nil {
			return err
		}

		// 跳过目录和非 Go 文件
		if info.IsDir() {
			return nil
		}
		if !strings.HasSuffix(path, ".go") {
			return nil
		}

		// 应用过滤器
		if filter != nil && !filter(info) {
			return nil
		}

		// 解析单个文件
		src, err := parser.ParseFile(fset, path, nil, mode)
		if err != nil {
			// 记录第一个错误但继续处理其他文件
			if firstError == nil {
				firstError = err
			}
			return nil
		}

		// 获取或创建包
		pkgName := src.Name.Name
		pkg, exists := pkgs[pkgName]
		if !exists {
			pkg = &ast.Package{
				Name:  pkgName,
				Files: make(map[string]*ast.File),
			}
			pkgs[pkgName] = pkg
		}

		// 添加文件到包
		pkg.Files[path] = src

		return nil
	})

	// 处理 Walk 错误
	if err != nil {
		return nil, err
	}

	// 如果有解析错误，返回部分结果和第一个错误
	if firstError != nil {
		return pkgs, firstError
	}

	return pkgs, nil
}

func main() {
	log.SetPrefix("[main]")
	if len(os.Args) < 3 {
		log.Fatal("Usage: gen-copier <source-type> <target-type>")
	}

	sourceTypeName := os.Args[1]
	targetTypeName := os.Args[2]
	log.Printf("Generating copier from %s to %s\n", sourceTypeName, targetTypeName)

	fset := token.NewFileSet()

	// 使用递归解析函数替代原来的 ParseDir 调用
	pkgs, err := ParseDirRecursive(fset, ".", nil, parser.AllErrors|parser.ParseComments)
	if err != nil {
		log.Fatal("Error parsing directory:", err)
	}
	log.Printf("Parsed %d packages\n", len(pkgs))

	var sourceType, targetType *ast.StructType
	var sourceFile string
	foundSource, foundTarget := false, false

	// 在解析的包中查找类型
	for pkgName, pkg := range pkgs {
		log.Printf("Scanning package: %s (%d files)\n", pkgName, len(pkg.Files))
		for fileName, file := range pkg.Files {
			log.Printf("  Scanning file: %s\n", fileName)
			ast.Inspect(file, func(n ast.Node) bool {
				ts, ok := n.(*ast.TypeSpec)
				if !ok {
					return true
				}

				// 只处理结构体类型
				structType, isStruct := ts.Type.(*ast.StructType)
				if !isStruct {
					return true
				}

				fullName := fmt.Sprintf("%s.%s", pkgName, ts.Name.Name)

				log.Printf("    Found struct type: %s\n", fullName)

				// 检查是否是我们要找的类型
				if fullName == sourceTypeName {
					log.Printf("      Found source type: %s\n", fullName)
					sourceType = structType
					sourceFile = fileName
					foundSource = true
				}
				if fullName == targetTypeName {
					log.Printf("      Found target type: %s\n", fullName)
					targetType = structType
					foundTarget = true
				}

				return true
			})
		}
	}

	if !foundSource {
		log.Fatalf("Source type %s not found", sourceTypeName)
	}
	if !foundTarget {
		log.Fatalf("Target type %s not found", targetTypeName)
	}

	// 生成复制器代码
	code, err := copier_generate.GenerateCopier(sourceTypeName, sourceType, targetTypeName, targetType)
	log.SetPrefix("[main]")
	if err != nil {
		log.Fatal("Error generating copier:", err)
	}

	// 确定输出文件名
	sourceParts := strings.Split(sourceTypeName, ".")
	outputFilename := strings.ToLower(sourceParts[len(sourceParts)-1]) + "_copier.go"

	// 获取源类型定义文件的目录
	sourceDir := filepath.Dir(sourceFile)
	if sourceDir == "." {
		sourceDir = "" // 当前目录不需要路径前缀
	} else {
		// 确保目录存在
		if _, err := os.Stat(sourceDir); os.IsNotExist(err) {
			if err := os.MkdirAll(sourceDir, 0755); err != nil {
				log.Fatal("Error creating output directory:", err)
			}
		}
	}

	// 使用源类型定义文件的目录作为输出路径
	outputPath := filepath.Join(sourceDir, outputFilename)
	file, err := os.Create(outputPath)
	if err != nil {
		log.Fatal("Error creating output file:", err)
	}
	defer file.Close()

	// 使用源类型的包名
	sourcePkg := sourceParts[0]

	// 写入完整的文件内容
	fullContent := fmt.Sprintf(`package %s

// Code generated by gen-copier; DO NOT EDIT.

%s`, sourcePkg, code)

	if _, err := file.WriteString(fullContent); err != nil {
		log.Fatal("Error writing to file:", err)
	}

	log.Printf("Successfully generated copier function in %s\n", outputFilename)
}
